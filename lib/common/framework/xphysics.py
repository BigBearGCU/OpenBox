#!/usr/bin/env python
##@file

##@namespace xphysics
# This module handles all physic related operations 
import os, sys

import pygame
from pygame.locals import *

from xvec2d import XVec2d
from xsprite import XSprite

TOP = 0x0001
BOTTOM = 0x0002
LEFT = 0x0004
RIGHT = 0x0008


## class XPhysics<br>
# Handles common based physics operations such as collision detection
# and dynamics 
#
# XSprite attributes of interest:
#   position
#   velocity
#   mass
#   elasticity
#   rect
#
# World attributes of interest:
#   gravity
#   friction
#
class XPhysics(object):
	
	## Constructor<br>
	# @param self The object pointer
    def __init__(self):
        self.reset()
	
	## Reset<br>
	# Resets the physics simulation back to the start
	# @param self The object pointer
    def reset(self):
        self.edgesRect = None
        self.gravity = None
        self.collisionTest = None
        self.collisionHandler = None
        self.hitEdgesHandler = None
        self.offEdgesHandler = None
        self.blobCollisionTest = None
        self.blobCollisionHandler = None
		
	##Set Gravity<br>
	# Sets the gravity used in the simulation
	# @param self The object pointer
	# @param gravity The new gravity used in the simulation
    def set_gravity(self, gravity):
        self.gravity = gravity
		
	##Set the edges of Simulated world<br>
	# This sets the boundary of the simulation, any object that collides
	# with this will be reflected back into the world
	# @param self The object pointer
	# @param rect The dimensions of the World
    def set_edges(self, rect):
        self.edgesRect = rect
		
	## Set Collision Test<br>
	# Sets if we are going to test for collisions in our World
	# @param self The object pointer
	# @param test Boolean defines if we are testing for collisions
    def set_collision_test(self, test):
        self.collissionTest = test
    
	## Set Collision Handler<br>
	# Sets the function that will be called when a collision
	# occurs.
	# @param self The object pointer
	# @param handler The function that will be called when a collision occurs
    def set_collision_handler(self, handler):
        self.collisionHandler = handler
	
	## Set the Collision handler for the edges of the World<br>
	# Sets the function that will be called when a collision occurs
	# with boundary with the world
	# @param self The Object pointer
	# @param handler The function that will handle coollison
    def set_hit_edges_handler(self, handler):
        self.hitEdgesHandler = handler
	
    def set_off_edges_handler(self, handler):
        self.offEdgesHandler = handler
		
	## Set blob Collision Test handler<br>
	# Sets the function that will be used to test for collision between
	# objects and the blobs generated by user movement via the webcam
	# @param self The object pointer
	# @param handler The function that will handle collision tests
    def set_blob_collision_test(self, handler):
        self.blobCollisionTest = handler
    
	## Set blob Collisions handler<br>
	# Sets the function that will be called when a collision occurs between
	# an object and a blob generated by user movement via the webcam
	# @param self The object pointer
	# @param handler The function that will handle collisions
    def set_blob_collision_handler(self, handler):
        self.blobCollisionHandler = handler
	
	## Update World<br>
	# This function updates the physics simulation and checks for collisions(if we 
	# set Collision tests to true)
	# @param self The object pointer
	# @param elapsedTime The elapsed time since the last update
	# @param buttonGroup A list of all buttons in our current simulation
	# @param spriteGroup A list of all sprites in our simulation
	# @param blobSprites A list of all blobs in our simulation(obtained from webcam)
    def update_world(self, elapsedTime, buttonGroup, spriteGroup, blobSprites):

        for sprite in spriteGroup:

            # remember old position and velocity
            sprite.oldpos = sprite.rect.center
            sprite.oldvel = (sprite.velocity.x, sprite.velocity.y)
            
            # apply external forces
            if self.gravity:
                sprite.velocity.y += self.gravity * elapsedTime

            # move object
            pos = sprite.rect.center
            pos += sprite.velocity * elapsedTime
            sprite.rect.center = pos

            if self.edgesRect:

                if self.hitEdgesHandler:
                    edgesFlags = 0x0
                    if sprite.rect.left < self.edgesRect.left:
                        edgesFlags |= LEFT
                    elif sprite.rect.right > self.edgesRect.right:
                        edgesFlags |= RIGHT
                    if sprite.rect.top < self.edgesRect.top:
                        edgesFlags |= TOP
                    elif sprite.rect.bottom > self.edgesRect.bottom:
                        edgesFlags |= BOTTOM
                    if edgesFlags != 0:
                        self.hitEdgesHandler(sprite, edgesFlags, elapsedTime)

                if self.offEdgesHandler:
                    edgesFlags = 0x0
                    if sprite.rect.right < self.edgesRect.left:
                        edgesFlags |= LEFT
                    elif sprite.rect.left > self.edgesRect.right:
                        edgesFlags |= RIGHT
                    if sprite.rect.bottom < self.edgesRect.top:
                        edgesFlags |= TOP
                    elif sprite.rect.top > self.edgesRect.bottom:
                        edgesFlags |= BOTTOM
                    if edgesFlags != 0:
                        self.offEdgesHandler(sprite, edgesFlags, elapsedTime)
                        
        if self.collisionHandler and self.collissionTest:
        
            collideDict = pygame.sprite.groupcollide(spriteGroup, spriteGroup, False, False)

            for sprite1 in collideDict:
                collideGroup = collideDict[sprite1]

                # remove sprite as it will be detected as hitting itself
                collideGroup.remove(sprite1)

                for sprite2 in collideGroup:
                    # remove duplicate collision in sprite2s group
                    collideDict[sprite2].remove(sprite1)

                    if self.collissionTest(sprite1, sprite2, elapsedTime):
                        # move back to last good position
                        # prevents objects moving inside each other
                        # which could give dist==0 and division by zero error
                        sprite1.rect.center = sprite1.oldpos
                        sprite2.rect.center = sprite2.oldpos
                        
                        # Call collision handler
                        self.collisionHandler(sprite1, sprite2, elapsedTime)
                        
        if self.blobCollisionHandler and self.blobCollisionTest and blobSprites:
            
            for blob in blobSprites:
                collideList = pygame.sprite.spritecollide(blob, spriteGroup, False)
                for sprite in collideList:
                    if self.blobCollisionTest(blob, sprite, elapsedTime):
                        self.blobCollisionHandler(blob, sprite, elapsedTime)           

        # Always built in collision test for buttons in order to keep consistency
        for blob in blobSprites:
            collideList = pygame.sprite.spritecollide(blob, buttonGroup, False)
            for button in collideList:
                if self.do_button_collision_test(button, blob, elapsedTime):
                    button.apply_motion(elapsedTime)
	
	## Check collision, using the radius of the sprite<br>
	# Check the collision between two sprites using the radius of 
	# the sprite, this is the fastest form of collision detection but
	# the least acruate
	# @param self The object pointer
	# @param sprite1 The first sprite submitted for collision detection
	# @param sprite2 The second sprite submitted for collision detection
	# @param elapsedTime The elapsed time since the last game update
	# @returns True if a collision occurs or False if not
    def do_radius_collision_test(self, sprite1, sprite2, elapsedTime):
        pos1 = XVec2d(sprite1.rect.center)
        pos2 = XVec2d(sprite2.rect.center)
        norm = pos1 - pos2
        return norm.length <= sprite1.radius + sprite2.radius
	
	## Check collision, using the actual pixels of the sprite<br>
	# Check the collision between two sprites down to the pixel level.
	# This is the slowest form of collision detection but is the most
	# acruate
	# @param self The object pointer
	# @param sprite1 The first sprite submitted for collision detection
	# @param sprite2 The second sprite submitted for collision detection
	# @param elapsedTime The elapsed time since the last game update
	# @returns True if a collision occurs or False if not
    def do_pixel_collision_test(self, sprite1, sprite2, elapsedTime):

        return check_collision(sprite1, sprite2)
	
	## Bounce the sprite off the edge of the screen<br>
	# This bounces a sprite off the edge of the simulated world
	# @param self The object pointer
	# @param flags What side of the sprite has collided with the edge
	# can be LEFT, RIGHT, TOP, BOTTOM
	# @param elapsedTime The elapsed Time since the last game update
	# @param dampen The vlaue that dampens the collision response
    def do_edge_bounce(self, sprite, flags, elapsedTime, dampen = 1):

        if flags & LEFT:
            sprite.rect.left = self.edgesRect.left
            sprite.velocity.x *= -dampen
            sprite.velocity.y *= dampen
        elif flags & RIGHT:
            sprite.rect.right = self.edgesRect.right
            sprite.velocity.x *= -dampen
            sprite.velocity.y *= dampen
        if flags & TOP:
            sprite.rect.top = self.edgesRect.top
            sprite.velocity.y *= -dampen
            sprite.velocity.x *= dampen
        elif flags & BOTTOM:
            # if fallen too far reduce effect of accel due to gravity
            if self.gravity:
                fallen = sprite.rect.bottom - sprite.oldpos[1]
                if fallen == 0: fallen = 1  # protect from division by zero
                toofar = sprite.rect.bottom - self.edgesRect.bottom
                sprite.velocity.y = sprite.oldvel[1] + (self.gravity * elapsedTime) * (toofar/fallen)
            sprite.rect.bottom = self.edgesRect.bottom            
            sprite.velocity.y *= -dampen
            sprite.velocity.x *= dampen
			
	## Do collision Vectors<br>
	# Carry out a collision response between two sprites, this will generate 
	# directional and force vectors and then apply them to the sprite
	# @param self The object pointer
	# @param sprite1 The first sprite we are going to apply a force to
	# @param sprite2 The second sprite we are going to apply a force to
	# @param elapsedTime The elapsed time since the last update
	# @param dampen The value used to dampen the force involved in the collision
    def do_collision_vectors(self, sprite1, sprite2, elapsedTime, dampen = 1):

        pos1 = XVec2d(sprite1.rect.center)
        mag1 = sprite1.velocity.length
        pos2 = XVec2d(sprite2.rect.center)
        mag2 = sprite2.velocity.length

        norm = pos1 - pos2
        dist = norm.length
        if dist == 0: dist = 1 # protect from division by zero

        vx1 = (mag2 * norm.x / dist) * dampen
        vy1 = (mag2 * norm.y / dist) * dampen
        vx2 = -(mag1 * norm.x / dist) * dampen
        vy2 = -(mag1 * norm.y / dist) * dampen

        sprite1.velocity = XVec2d(vx1, vy1)
        sprite2.velocity = XVec2d(vx2, vy2)
		
	## Do blob colllision test<br>
	# Carry a collision between a sprite and blob generated by webcam interaction
	# @param self The object pointer
	# @param blob The blob generated by the webcam
	# @param sprite The sprite we are checking collisions with
	# @param elapsedTime The elapsed time since the last game update
	# @returns True if a collision occurs or False if not
    def do_blob_collision_test(self, blob, sprite, elapsedTime):
 
        return (sprite.rect.collidelist(blob.rects) <> -1)
	
	##Do blob collision test with a delay<br>
	# @see Do blob colllision test
    def do_blob_collision_test_with_delay(self, blob, sprite, elapsedTime):
        
        try:
            if sprite.blobHitTime <= 0:
                if self.do_blob_collision_test(blob, sprite, elapsedTime):
                    sprite.blobHitTime = 500
                    return True
            else:
                #print "ignoring", sprite.id
                sprite.blobHitTime -= elapsedTime
        except:
            if self.do_blob_collision_test(blob, sprite, elapsedTime):
                sprite.blobHitTime = 500
                return True
        return False
	
	## Do button collision test<br>
	# Carry out a collision test between a blob generated by webcam interaction
	# and a button
	# @param self The object pointer
	# @param button The button we are going to test
	# @param blob The blob we are going to test
	# @returns True if a collision occurs or False if not
    def do_button_collision_test(self, button, blob, elapsedTime):
        return (button.rect.collidelist(blob.rects) <> -1)
	
## Checks if two objects have collided, using hitmasks<br>
# A hitmask is just a texture map that can be used for per pixel collision
# tests. This will be faster than normal per pixel collision tests
# from http://www.pygame.org/wiki/FastPixelPerfect?parent=CookBook
# @param obj1 The first sprite we are going to check for collisions
# @param obj2 The second sprite we are using for collision detection 
# @returns True if a collision occurs or False if not
def check_collision(obj1,obj2):
    
    try:rect1, rect2, hm1, hm2 = obj1.rect, obj2.rect, obj1.hitmask, obj2.hitmask
    except AttributeError:return False
    rect=rect1.clip(rect2)
    if rect.width==0 or rect.height==0:
        return False
    x1,y1,x2,y2 = rect.x-rect1.x,rect.y-rect1.y,rect.x-rect2.x,rect.y-rect2.y
    for x in xrange(rect.width):
        for y in xrange(rect.height):
            if hm1[x1+x][y1+y] and hm2[x2+x][y2+y]:return True
            else:continue
    return False

#--------------------------------------------------------------------
